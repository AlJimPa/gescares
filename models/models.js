var path = require('path');
var log = appGlobals.logger.createLogger('models');

// Postgres DATABASE_URL = postgres://user:passwd@host:port/database
// SQLite	DATABASE_URL = sqlite://:@:/
var url = appGlobals.config.dataBaseURL.match(/(.*)\:\/\/(.*?)\:(.*)@(.*)\:(.*)\/(.*)/);
var DB_name  = (url[6]||null);
var user	 = (url[2]||null);
var pwd	 	 = (url[3]||null);
var protocol = (url[1]||null);
var dialect	 = (url[1]||null);
var port	 = (url[5]||null);
var host	 = (url[4]||null);
var storage = appGlobals.config.dataBaseStorage;
var dialectOptions = {};
if (appGlobals.config.dataBaseUseSSL)
	dialectOptions.ssl = true;
log.info('INITIALIZATING SEQUELIZE');
// Load ORM Model
var Sequelize = require('sequelize');

// Use SQLite or Postgres DB
var sequelize = new Sequelize(DB_name, user, pwd,
	{dialect:  protocol, 
	 protocol: protocol,
	 port:	   port,
	 host:     host,
	 storage:  storage, // only SQLite (.env)
	 omitNull: true,		// only Postgres
	 dialectOptions: dialectOptions,
	 define: {
		 instanceMethods:{
			 /** 
			  * Check if object matches with instance. Useful for update checks 
			  * @method objectEquals 
			  * @param {Object} object Current object to be evaluated 
			  * @param {boolean} checkAutogen=false Check autogenerated values, such as createdAt or updatedAt
			  * @return {boolean}
			 */
			 //for (var obj in dcArray[0].dataValues){ if(obj !== 'createdAt' && obj !== 'updatedAt') console.log(obj);}
			 objectEquals: function(object, checkAutogen){
				if (object === undefined || object === null)
					return false;
				if (checkAutogen === undefined || checkAutogen === null)
					checkAutogen = false;
				for (var key in this.dataValues){
					if (!checkAutogen && (key === 'createdAt' || key === 'updatedAt'))
						continue;
					if (object[key] !== this[key])
						return false;
				}
				return true;
			}
		 }
	 }
   }
);

log.info('IMPORTING DEFINITIONS');
// Import definitions
//Type
var typePath = path.join(__dirname, 'type');
var Type = sequelize.import(typePath);
//Category
var categoryPath = path.join(__dirname, 'category');
var Category = sequelize.import(categoryPath);
//Component
var componentPath = path.join(__dirname, 'component');
var Component = sequelize.import(componentPath);
//Allergenic
var allergenicPath = path.join(__dirname, 'allergenic');
var Allergenic = sequelize.import(allergenicPath);
//Dish
var dishPath = path.join(__dirname, 'dish');
var Dish = sequelize.import(dishPath);
//Price
var pricePath = path.join(__dirname, 'price');
var Price = sequelize.import(pricePath);
//Image
var imagePath = path.join(__dirname, 'image');
var Image = sequelize.import(imagePath);
//DishComponent
var dishComponentPath = path.join(__dirname, 'dish_component');
var DishComponent = sequelize.import(dishComponentPath);
//DishAllergenic
var dishAllergenicPath = path.join(__dirname, 'dish_allergenic');
var DishAllergenic = sequelize.import(dishAllergenicPath);

// Define relations
log.info('DEFINING RELATIONS');
//Type-Dish (1-N)
Dish.belongsTo(Type, {foreignKey: {allowNull: false}, onDelete: 'CASCADE'});
Type.hasMany(Dish);
//Category-Dish (N-M) - no need to define table in a separate file, as it doesn't have other atributes rather than FKs
var DishCategory = sequelize.define('DishCategory', {});
Category.belongsToMany(Dish, {through: 'DishCategory'});
Dish.belongsToMany(Category, {through: 'DishCategory'});
//Dish-Price (1-N)
Dish.hasMany(Price);
Price.belongsTo(Dish, {foreignKey: {allowNull: false}, onDelete: 'CASCADE'});
//Dish-Image (1-N)
Dish.hasMany(Image);
Image.belongsTo(Dish, {foreignKey: {allowNull: false}, onDelete: 'CASCADE'});
//Dish-DishComponent (1-N)
Dish.hasMany(DishComponent);
DishComponent.belongsTo(Dish, {foreignKey: {allowNull: false}, onDelete: 'CASCADE'});
//Dish-DishAllergenic (1-N)
Dish.hasMany(DishAllergenic);
DishAllergenic.belongsTo(Dish, {foreignKey: {allowNull: false}, onDelete: 'CASCADE'});

log.info('PREPARING EXPORTS');
// Exports
exports.Type = Type;
exports.Category = Category;
exports.Component = Component;
exports.Allergenic = Allergenic;
exports.Dish = Dish;
exports.Price = Price;
exports.Image = Image;
exports.DishCategory = DishCategory;
exports.DishComponent = DishComponent;
exports.DishAllergenic = DishAllergenic;
//Sequelize exports
//exports.sequelizeTransaction = Sequelize.prototype.transaction;//doesn't work without dependencies?
exports.resolvePromise = sequelize.Promise.resolve;

// Initialize database
log.info('INITIALIZATING DATABASE');
//returning next element's count promise and using it in the next function is a way to keep the chain without nesting
//sample files have less than 10 rows for each model; for new tables with huge numbers of rows to be initialized, consider to use bulk operations
var fs = require('fs');
var samplesDir = appGlobals.config.modelSamplesDir;
var initialSequenceId = appGlobals.config.dataBaseInitialSequenceId;
var insertTotals = {};

sequelize.sync().then(function() {
	log.info('TABLES CREATED; LOADING SAMPLE DATA IF NEEDED');
	Type.count().then(
		//initial type inserts
		function(count){
			log.debug('-Type');
			if (count === 0){
				var types = JSON.parse(fs.readFileSync(samplesDir + 'types.json', 'UTF-8'));
				insertTotals.Types = types.length;
				for (var index in types){
					Type.create({
						id: types[index].id + initialSequenceId,
						text: types[index].text
					});
				}
			}
			return Category.count();
		}
	).then(
		//initial category inserts
		function(count){
			log.debug('-Category');
			if (count === 0){
				var categories = JSON.parse(fs.readFileSync(samplesDir + 'categories.json', 'UTF-8'));
				insertTotals.Categories = categories.length;
				for (var index in categories){
					Category.create({
						id: categories[index].id + initialSequenceId,
						text: categories[index].text
					});
				}
			}
			return Component.count();
		}
	).then(
		//initial component inserts
		function(count){
			log.debug('-Component');
			if (count === 0){
				var components = JSON.parse(fs.readFileSync(samplesDir + 'componentHints.json', 'UTF-8'));
				insertTotals.Components = components.length;
				for (var component in components){
					Component.create({
						text: components[component]
					});
				}
			}
			return Allergenic.count();
		}
	).then(
		//initial allergenic inserts
		function(count){
			log.debug('-Allergenic');
			if (count === 0){
				var allergenics = JSON.parse(fs.readFileSync(samplesDir + 'allergenicHints.json', 'UTF-8'));
				insertTotals.Allergenics = allergenics.length;
				for (var allergenic in allergenics){
					Allergenic.create({
						text: allergenics[allergenic]
					});
				}
			}
			return Dish.count();
		}
	).then(
		//initial dish inserts - types required
		function(count){
			log.debug('-Dish');
			if (count === 0){
				var dishDataDir = samplesDir + 'dishes/';
				var files = fs.readdirSync(dishDataDir);
				insertTotals.Dishes = files.length;
				for (var i = 0; i < files.length; i++){
					var data = fs.readFileSync(dishDataDir + files[i], 'UTF-8');
					dish = JSON.parse(data);
					Dish.create({
						id: dish.id + initialSequenceId,
						name: dish.name,
						description: dish.description,
						TypeId: dish.type + initialSequenceId//FK
					});
				}
			}
			return DishCategory.count();
		}
	).then(
		//initial dishCategory inserts - dish and category required
		function(count){
			log.debug('-DishCategory');
			if (count === 0){
				var total = 0;
				var dishDataDir = samplesDir + 'dishes/';
				var files = fs.readdirSync(dishDataDir);
				for (var i = 0; i < files.length; i++){
					var data = fs.readFileSync(dishDataDir + files[i], 'UTF-8');
					dish = JSON.parse(data);
					if (dish.categories === undefined) { continue };
					total += dish.categories.length;
					for (var j = 0; j < dish.categories.length; j++){
						DishCategory.create({
							DishId: dish.id + initialSequenceId,
							CategoryId: dish.categories[j] + initialSequenceId
						});
					}
				}
				insertTotals.DishCategories = total;
			}
			return Price.count();
		}
	).then(
		//initial price inserts - dish required
		function(count){
			log.debug('-Price');
			if (count === 0){
				var total = 0;
				var dishDataDir = samplesDir + 'dishes/';
				var files = fs.readdirSync(dishDataDir);
				for (var i = 0; i < files.length; i++){
					var data = fs.readFileSync(dishDataDir + files[i], 'UTF-8');
					dish = JSON.parse(data);
					if (dish.Prices === undefined) { continue };
					total += dish.Prices.length;
					for (var j = 0; j < dish.Prices.length; j++){
						Price.create({
							concept: dish.Prices[j].concept,
							price: dish.Prices[j].price,
							currency: dish.Prices[j].currency,
							DishId: dish.id + initialSequenceId
						});
					}
				}
				insertTotals.Prices = total;
			}
			return Image.count();
		}
	).then(
		//initial image inserts - dish required
		function(count){
			log.debug('-Image');
			if (count === 0){
				var total = 0;
				var dishDataDir = samplesDir + 'dishes/';
				var files = fs.readdirSync(dishDataDir);
				for (var i = 0; i < files.length; i++){
					var data = fs.readFileSync(dishDataDir + files[i], 'UTF-8');
					dish = JSON.parse(data);
					if (dish.Images === undefined) { continue };
					total += dish.Images.length;
					for (var j = 0; j < dish.Images.length; j++){
						Image.create({
							source: dish.Images[j].source,
							link: dish.Images[j].link,
							description: dish.Images[j].description,
							DishId: dish.id + initialSequenceId
						});
					}
				}
				insertTotals.Images = total;
			}
			return DishComponent.count();
		}
	).then(
		//initial dishComponent inserts - dish required
		function(count){
			log.debug('-DishComponent');
			if (count === 0){
				var total = 0;
				var dishDataDir = samplesDir + 'dishes/';
				var files = fs.readdirSync(dishDataDir);
				for (var i = 0; i < files.length; i++){
					var data = fs.readFileSync(dishDataDir + files[i], 'UTF-8');
					dish = JSON.parse(data);
					if (dish.Components === undefined) { continue };
					total += dish.Components.length;
					for (var index in dish.Components){
						DishComponent.create({
							text: dish.Components[index],
							DishId: dish.id + initialSequenceId
						});
					}
				}
				insertTotals.DishComponents = total;
			}
			return DishAllergenic.count();
		}
	).then(
		//initial dishAllergenic inserts - dish required
		function(count){
			log.debug('-DishAllergenic');
			if (count === 0){
				total = 0;
				var dishDataDir = samplesDir + 'dishes/';
				var files = fs.readdirSync(dishDataDir);
				for (var i = 0; i < files.length; i++){
					var data = fs.readFileSync(dishDataDir + files[i], 'UTF-8');
					dish = JSON.parse(data);
					if (dish.Allergenics === undefined) { continue };
					total += dish.Allergenics.length;
					for (var index in dish.Allergenics){
						DishAllergenic.create({
							text: dish.Allergenics[index],
							DishId: dish.id + initialSequenceId
						});
					}
				}
				insertTotals.DishAllergenics = total;
			}
			return DishAllergenic.count();			
		}
	).then(	
		function(count){
			/*
			//DEBUG - check data 
			function printTable(tableRows){
				if (tableRows.length === 0)
					return;
				var tableName = tableRows[0].Model.tableName;
				var insertDetail = '';
				if (insertTotals[tableName] !== undefined){
					insertDetail += ' inserted '
						+ tableRows.length + '/' + insertTotals[tableName];
				}
					
				log.debug('[Model: ' + tableName + insertDetail + ']');
				for (var i = 0; i < tableRows.length; i++){
					var strRow = JSON.stringify(tableRows[i]);
					var row = JSON.parse(strRow);
					delete row.createdAt;
					delete row.updatedAt;
					log.debug(JSON.stringify(row));					
				}
			};
			var models = [Type, Category, Component, Allergenic, Dish, Price, Image, DishCategory, DishComponent, DishAllergenic];
			//models = [Price, DishComponent, DishAllergenic];
			for (var index in models){
				models[index].findAll().then(printTable);
			}
			//END DEBUG
			/**/
			log.notice('Database initialization done');
	});
});

